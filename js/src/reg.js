/*
    一、概论
    RegExp 正则用来处理字符串，它是一个规则
    可以验证字符串是否符合某个规则（test），
    也可以把字符串中符合规则的内容捕获（exec / match…）

    test() 是否满足条件
    exec() 返回满足条件的值

    二、编写正则表达式
    创建方式两种
    1、字面量创建方式(两个斜杠间包起来，都是用来描述规则的元字符)
        let reg1 = /\d+0/;  // 连续的数字
    2、构造函数模式创建  两个参数：元字符字符串，修饰符字符串
        let reg2 = new RegExp("\\d+");

    三、正则表达式有两部分组成：元字符、修饰符
    常用元字符
    1、量词元字符：设置出现的次数
        * 零到多次，(可以出现可以不出现而且出现的次数可以很多次)
        + 一到多次，
        ? 零次或一次，（要么不出现，出现就只出现一次）
        {n} 出现n次(零或正整数)
        {n,} 出现n到多次
        {n,m} 出现n到m次
        
    2、特殊元字符：单个或者组合在一起代表特殊的含义
        \   转义字符(普通->特殊->普通)
        .   除\n(换行符)以外的任意字符
        ^   以哪一个元字符作为开始
        $   以哪一个元字符作为结束
        \d  0~9之间的数字
        \D  非0-9之间的一个数字
        \w  数字、字母、下划线中的任意一个字符
        \W  非数字、字母、下划线中的任意一个字符
        \s  一个空白字符（包含空格、制表、换页符等）
        \t  一个制表符（一个tab键：四个空格）
        \b  匹配一个单词的边界
        x|y     x或者y中的一个字符  eg:1|8|9
        [xyz]   x或者y或z中的一个字符 eg: [adgh,321]
        [^xy]   除x\y以外的任意字符
        [a-z]   指定a-z这个范围内的任意字符 eg: [0-9a-zA-z_]===\w
        [^a-z]  上一个的取非
        ()   分组符
        (?:)  只匹配不捕获
        (?=) 正向预查
        (?!) 负向预查

    3、普通元字符：代表本身含义的
        /hairong/   匹配的就是"hairong"

    常用修饰符
        i => ignoreCase 忽略单词大小写匹配
        m => multiline  可以进行多行匹配
        g => global     全局匹配


    例子：
        正则：/^2.3$/     // 2.3 2]3 2)3 2@3 都匹配 23不匹配
        （.不代表小数点如需代表小数点加转义符\.） /^2\.3$/

        匹配\d，把特殊符合转换为普通的（字符串中有特殊含义的符号也需要转义）
        正则： /^\\d$/.test("\\d")

        正则：/^18|29$/   
        // 18\29\129\189\1829\829\182 ture
        //  82\1289     false
        ----
            直接x|y会存在很乱的优先级问题，一般我们写的时候都伴随着
            小括号进行分组，因为小括号改变处理的优先级=>小括号：分组

            上述正则改为：/^(18|29)$/ 只能是18或29中的一个了
        ----

        []中出现的字符一般大部分都代表本身的含义
        正则：/^[@+]+$/     // @或+出现一到多次
        // @@ ++ @@+@   true
        改为：/^[@+]$/    上述测试用例为false
        
        （具有特殊转义如\d\w这些还是原本的含义除非转义）
        /^\d$/      /^\\d$/

        不存在多位数
        /^[18]$/    1或8，18不行
        /^[10-29]$/    匹配1或者0-2或者9
        
    四、常用的正则表达式
    1、验证是否为有效数字
    规则分析：
        1、可能出现+ - 号，也可能不出现
        2、一位0-9都可以，多位首页不能为0
        3、小数部分可能有可能没有，一旦有后面必须有小数点+数字
        
        /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;

    2、验证密码
    规则分析：
        1、数字、字母、下划线
        2、6-16位

        /^\w{6,16}$/

    3、验证真实姓名
    规则分析：
        1、汉字     /^[\u4e00-\u9fa5]$/ (汉字的第一个Unicode编码值到最后一个Unicode编码值)
        2、名字长度2-10位
        3、可能有译名   ·汉字 ·汉字·汉字(两个点也有更多点就用*)   (·[\u4e00-\u9fa5]{2,10}){0,2}
        
        /^[\u4e00-\u9fa5]{2,10}(·[\u4e00-\u9fa5]{2,10}){0,2}$/

    4、验证邮箱
    
    /^\w+((-\w+)|(.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
    
    规则分析：
        1、开头可以是数字、字母、下划线（1到多位）  
        2、开头后@符前 -数字字母下划线 或者 .数字字母下划线(整体零到多次)
        3、邮箱名字由"数字、字母、下划线、-、."几部分组成，但是-/.不能连续
            出现也不能作为开始      \w+((-\w+)|(.\w+))*
        4、@后面紧跟着：数字、字母（1到多位）   @[A-Za-z0-9]+

        5、 ((\.|-)[A-Za-z0-9]+)*   对@后面名字的补充，
            能出现多域名(.com.cn/qq.com……)或者企业域名(@ccbu-lou.cn.com……)

        5、 \.[A-Za-z0-9]+  @xxx.com @xxx.cn    
            匹配的最后的域名(.com/.cn/.org/.net/.vip……)

        wang-hai.rong@qq.com
        wang-hai-rong@qq.com
        wang.hai.rong@qq.com
        13244@qq.com
        @xxx.com

    5、身份证号码（第二代）
    规则分析：
        1、一共18位
        2、最后一位可能是大写X（大写X代表10）
        3、身份证前六位：省市县
        4、中间八位：年月日
        5、最后四位：最后一个x或数字，倒数第二位偶数是女奇数是男，其余是经过算法算出来的
        /^\d{17}(\d|x)$/

        =>小括号分组的第二个作用：分组捕获，不仅可以把大正则匹配的信息捕获到，
        还可以单独捕获到每一个小分组的内容

        /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|x)$/
        reg.exec("430422199711229743")  // 捕获结果如下
        0: "430422199711229743"
        1: "430422"
        2: "1997"
        3: "11"
        4: "22"
        5: "4"
        6: "3"

    五、两种创建方式的区别
    //=> 构造函数因为传递的是字符串，\需要写两个才代表斜杆
        /^\d+$/g
        new RegExp("\\d+", "g")

    //=> 正则表达式中的部分内容是变量存储的值
    1、两个斜杠中间包起来的都是元字符，字面量不能接受变量值，只能用构造函数方式
        let type = "hairong"
        new RegExp("^@"+type+"@$")

    六、正则捕获的懒惰性（个人觉得不是很重要）
    基于exec实现正则的捕获
    1、捕获到的结果是null或者一个数组
        数组第一项：本次捕获到的内容
        其余项：对应小分组本次单独捕获的内容
        index: 当前捕获内容在字符串中的起始索引
        input：原始字符串
    2、每执行一次exec只能捕获到一个符合正则规则的
    => "正则捕获的懒惰性"：默认只捕获第一个
    解决办法：用全局修饰符g

    let str = "whr2019whr2020wjr2021";
    let reg = /\d+/;

    lastIndex: 当前正则下一次匹配的起始索引位置
    懒惰性捕获的原因：默认情况下lastIndex的值不会被修改，每一次都是从字符串开始
    位置，所以找到的永远只是第一个。

    console.log(reg.lastIndex); // =>0 下面匹配捕获是从STR索引零的位置开始找
    console.log(reg.exec(str));
    console.log(reg.lastIndex); // =>0 第一次匹配捕获完成，lastIndex没有改变，
    所以下次exec依然是从字符串最开始找，找到的永远是第一个匹配的。
    
    reg.lastIndex = 8; // 手动改只是改变私有属性的值，并没有影响正个正则处理的核

    let reg = /\d+/g;
    console.log(reg.exec(str));  // 2019
    console.log(reg.lastIndex); //=> 8 设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改
    
    ^^^^获取所有符合匹配结果得值——自定义函数（同match方法）
    let str = 'whr2019whr2020wjr2021';
    let reg = /\d+/g;
    ~(function() {
        function execAll(str) {
            let arr = [],
                res = this.exec(str);
            if (!this.global) return res[0];
            while (res) {
                arr.push(res[0]);
                res = this.exec(str);
            }
            return arr;
        }
        RegExp.prototype.execAll = execAll;
    })();
    console.log(reg.execAll(str));  // [2019,2020,2021]
    ……………………

    七、正则捕获得贪婪性
    =>贪婪性:默认情况下正则捕获得时候是按照当前正则所匹配得最长结果来获取的
    
    let str = "whr2019whr2020wjr2021";
    let reg = /\d+?/g;  // ["2", "0", "1", "9", "2", "0", "2", "0", "2", "0", "2", "1"]

    =>在量词元字符后面设置?,取消捕获时候的贪婪性（按照正则匹配的最短结果来获取）
    ?左边是非量词元字符：本身代表量词元字符，出现零到一次
    ?左边是量词元字符：取消捕获时候的贪婪性
    (?:) 只匹配不捕获
    (?=) 正向预查(必须符合表达式)
    (?!) 负向预查(必须不符合表达式)

    八、正则其他捕获方法
    1、 一下知道了解就可以了
    let str = "{0}年{1}月{2}日";
    let reg = /\{(\d+)}/g;
    console.log(reg.test(str)); //=> true
    console.log(RegExp.$1); //=> "0"
    
    console.log(reg.test(str)); //=> true
    console.log(RegExp.$1); //=> "1"
    
    console.log(reg.test(str)); //=> true
    console.log(RegExp.$1); //=> "2"
    
    console.log(reg.test(str)); //=> true
    console.log(RegExp.$1); //=> "2" 存储的是上次捕获的结果
    
    RegExp.$1~RegExp.$9; 获取当前本次正则匹配后，第一个到第九个分组的信息

    2、replace字符串中实现替换的方法（一般都是伴随正则一起使用的）
    let str = "whr@2019|whr@2020";
    //=> 把whr替换成王海容
    str = str.replace(/whr/g,"王海容")

    案例：把时间字符串进行处理
    let time = "2019-02-13";
    //=> 变为2019年02月13日

    let reg = /^(\d{4})-(\d{1,2})-(\d{1,2})$/
    time.replace(reg, "$1年$2月$3日")

    //=> [str].replace([reg],[function])
    1、首先拿reg和time进行匹配捕获，能匹配到几次就会把传递的函数执行
    几次（而且是匹配一次就执行一次）
    2、不仅把方法执行，而且replace还给方法传递了实参信息（和exec捕获的
    内容一致的信息：大正则匹配的内容、小分组匹配的信息……）
    3、在函数中返回的什么，就把当前大正则匹配的内容替换成啥
    time = replace(reg,(big, ...arg)=>{
        return "@"
    })

    单词首字母大写
    let str = "good good study day day up";
    let reg = /\b([a-zA-Z])[a-zA-Z]*\b/g;
    //=> 函数被执行六次
    str = str.replace(reg,(...arg)=>{
        let [content, $1]=arg;
        $1=$1.toUpperCase();
        content = content.substring(1);
        return $1+content;
    })

    let time = "2019-8-13 16:51:3"
    //=> "08月13日 16时51分"
    //=> "2019年08月13日"

    // queryUrlParams
    let url = "https://www.baidu.com/s?wd=ert&sa=ire_dl_gh_logo&rsv_dl=igh_logo_pc";
    let obj = {}; 
    url.replace(/([^?=&#]+)=([^?=&#]+)/g,(...[, $1, $2])=> obj[$1]=$2);
    url.replace(/#([^?=&#]+)/g, (...[, $1])=>obj['hash']=$1);
    
    // 千分符
    12346678800.341
    12,346,678,800.34
    
    let str = 12346678800.46; // 123 466 788 00
    str = typeof str !== 'string' ? str.toString() : str;
    let dot = /\.\d{0,2}/;
    let reg = /\d{1,3}(?=(\d{3})+$)/g;
    let strMatch = str.match(dot);
    let dotStr = strMatch && strMatch[0];
    let dotIndex = strMatch && strMatch['index'];
    if (dotIndex) str = str.slice(0, dotIndex);
    console.log(dotStr, dotIndex);
    console.log(`${str.replace(reg, '$&,')}${dotStr ? dotStr : '.00'}`, '研究2');

*/
