function Fn(name, age) {
    var n = 10;
    this.namee = name;
    this.age = age + n;
}
Fn();
/*
    => 普通函数执行
    1、形成一个私有的作用域
    2、形参赋值
    3、变量提升
    4、代码执行
    5、栈内存释放问题
*/
var f = new Fn('xxx', 18);
/* 
    => 构造函数执行
    1、像普通函数执行一样，形成一个私有作用域（栈内存）
        私有变量：形参赋值、变量提升
    2、【构造函数执行独有】在js代码自上而下执行之前，首先
    在当前形成的私有栈中创建一个对象（创建一个堆内存：暂时不存储任何东西），
    并且让函数中的执行主体（THIS）指向这个新的堆内存（THIS===创建的对象）
    3、代码自上而下执行
    4、【构造函数执行独有】代码执行完成，把之前创建的堆内存地址返回（浏览器
    默认返回）
    => 构造函数代码执行中this.xxx都是给实例设置“私有属性”，最后浏览器会把默认创建的实例
    返回，供外接收。只有this.xxx才和实例有关系
    => 构造函数执行，不写return，浏览器会默认返回创建的实例，但是如果我们自己写了return
        1、return的是一个基本值，返回的结果依然是类的实例，没有受到影响
        2、如果返回的是引用值，则会把默认返回的实例覆盖，此时接收到的结果就不再是类的实例了
        尽量少用return，防止覆盖实例
    => new fn() new fn; 构造函数执行的时候，如果fn不需要传递实参，我们可以省略小括号，意思
    还是创建实例（和加小括号除了运算符优先级是没有区别）
    => instanceof: 检测某一个实例是否隶属于这个类
        所有的对象，包含创建的实例都是Object的实例
        1 instanceof number（instanceof不能检测字面量创建的基础数据类型）
    => in: 检测当前对象是否存在某个属性（不管当前这个属性是对象的私有属性还是公有属性，
        只要有结果就是true）
    => hasOwnProperty: 检测当前属性是否为对象的私有属性（不仅要有这个属性，而且必须还是私有的才可以）
*/

/* 
    [函数]
        普通函数、类(所有类：内置类、自己创建的类)、Date(是个类)
    [对象]
        普通对象、数组、正则、Math、arguments……
        实例是对象类型的(除了基本类型的字面量创建的值)
        prototype的值也是对象类型的
        函数也是对象类型的
        ……
    1、所有的函数数据类型都天生自带一个属性：prototype（原型），这个属性的值是一个对象，
        浏览器会默认给它开辟一个堆内存
    2、浏览器给prototype开辟的堆内存当中有一个天生自带的属性：constructor，这个属性存储
        的值是当前函数本身
    3、每一个对象(prototype就是个对象)都有一个__proto__的属性，这个属性指向当前实例所属
        类的原型（prototype）（如果不能确定它是谁的实例，那么都是object的实例）

    => 每一个类都把供实例调取的公共属性方法，存储到自己的原型上（原型（prototype）的作用：就是存储
    一些公共属性和方法供它的实例调取使用）

    => 基类Object的原型上的__proto__指向null，因为到最底层类，如果要指向也是指向自身，没有意义。

    =>原型链（__proto__）：它是一种基于__proto__向上查找的机制。当我们操作实例的某个属性或者方法的时候，
    首先找自己空间中私有的属性或者方法。
    1、找到了，则接收查找，使用自己私有的即可。
    2、没有找到，则基于__proto__找所属类的prototype，如果找到就用这个公有的，如果没找到，基于原型上的
    __proto__继续向上查找，一直找到Object.prototype的原型为止，如果再没有，则操作的属性或方法不存在。

    f1.__proto__.name = xxx // 给原型上设置公有属性（每个实例都可以用这个属性）
    Fn.prototype.name = xxx
*/
